{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>This project is in early development and is not production-ready. Use at your own risk.</p>"},{"location":"#csmt-compact-sparse-merkle-tree","title":"CSMT - Compact Sparse Merkle Tree","text":""},{"location":"#what-is-csmt","title":"What is CSMT?","text":"<p>A Compact Sparse Merkle Tree is a space-efficient variant of a Merkle tree optimized for sparse key spaces. It enables cryptographic proofs of inclusion (or exclusion) while minimizing storage requirements through path compression.</p>"},{"location":"#features","title":"Features","text":"<p>This package provides:</p> <ul> <li>Haskell Library: A CSMT implementation with persistent storage backends, offering efficient insertion, deletion, and proof generation for applications requiring verifiable data structures.</li> <li>CLI Tool: Interactive command-line interface for tree operations including adding/removing elements, generating proofs, and verifying membership.</li> <li>Preimage Storage: Automatic storage of key-value preimages in sync with the CSMT, enabling value retrieval alongside proof verification.</li> </ul>"},{"location":"#performance","title":"Performance","text":"<p>Preliminary benchmarks indicate that the CSMT library sustains a throughput of 900 insertions per second on a standard development machine over a 3.5M cardano UTxOs dataset.</p> <p>There is room for optimization via parallel insertions, but these results are promising for an initial implementation.</p>"},{"location":"#quick-start","title":"Quick Start","text":"CLILibrary <pre><code>export CSMT_DB_PATH=./mydb\ncsmt\n&gt; i key1 value1\n&gt; q key1\nAQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n</code></pre> <pre><code>import CSMT\nimport CSMT.Backend.RocksDB\n\nmain = withRocksDB \"mydb\" 256 256 $ \\runDB -&gt; do\n    runDB $ runTransaction $\n        insert fromKVHashes kvCol csmtCol \"key\" \"value\"\n</code></pre>"},{"location":"#status","title":"Status","text":""},{"location":"#library","title":"Library","text":"<ul> <li> Insertion and deletion</li> <li> Proof generation and verification</li> <li> Persistent storage (RocksDB)</li> <li> Comprehensive tests</li> <li> Insertion benchmarks</li> <li> Deletion/proof benchmarks</li> <li> Production-grade testing</li> <li> Raw key support (vs hashed keys)</li> </ul>"},{"location":"#cli-tool","title":"CLI Tool","text":"<ul> <li> Add/remove elements</li> <li> Query elements</li> <li> Generate and verify proofs</li> </ul>"},{"location":"#planned","title":"Planned","text":"<ul> <li> HTTP service with RESTful API</li> <li> Parallel batch insertions</li> </ul>"},{"location":"concepts/","title":"Concepts","text":"<p>This page explains the key concepts behind Compact Sparse Merkle Trees.</p>"},{"location":"concepts/#merkle-trees","title":"Merkle Trees","text":"<p>A Merkle tree is a binary tree where:</p> <ul> <li>Each leaf node contains the hash of a data block</li> <li>Each internal node contains the hash of its two children</li> </ul> <pre><code>graph TD\n    Root[Root Hash] --&gt; L[Hash AB]\n    Root --&gt; R[Hash CD]\n    L --&gt; A[Hash A]\n    L --&gt; B[Hash B]\n    R --&gt; C[Hash C]\n    R --&gt; D[Hash D]</code></pre> <p>This structure enables Merkle proofs - compact proofs that a specific piece of data is part of the tree. To prove inclusion of data A, you only need:</p> <ol> <li>Hash of A</li> <li>Hash B (sibling)</li> <li>Hash CD (uncle)</li> </ol> <p>With these three hashes, anyone can recompute the root and verify the proof.</p>"},{"location":"concepts/#sparse-merkle-trees","title":"Sparse Merkle Trees","text":"<p>A Sparse Merkle Tree (SMT) is a Merkle tree where:</p> <ul> <li>Keys determine the path through the tree (each bit = left or right)</li> <li>Most leaves are empty (hence \"sparse\")</li> <li>The tree depth equals the key length in bits</li> </ul> <p>For a 256-bit key, a naive SMT would have 2^256 possible leaves - far too large to store explicitly.</p>"},{"location":"concepts/#compact-sparse-merkle-trees","title":"Compact Sparse Merkle Trees","text":"<p>A Compact SMT optimizes storage by:</p> <ol> <li>Path compression: Empty subtrees are not stored</li> <li>Jump paths: Instead of storing each node on the path, we store a \"jump\" directly to where the data diverges</li> </ol>"},{"location":"concepts/#path-compression-example","title":"Path Compression Example","text":"<p>Consider inserting keys <code>LLRR</code> and <code>LRRL</code>:</p> <p>Without compression (naive SMT): <pre><code>Root \u2192 L \u2192 L \u2192 R \u2192 R \u2192 value1\n     \u2198 R \u2192 R \u2192 L \u2192 value2\n</code></pre></p> <p>With compression (CSMT): <pre><code>Root \u2192 L (jump to divergence point)\n       \u251c\u2500\u2500 L,RR \u2192 value1  (jump = RR)\n       \u2514\u2500\u2500 R,RL \u2192 value2  (jump = RL)\n</code></pre></p> <p>The CSMT stores only the nodes where paths actually diverge, plus \"jump\" metadata indicating how many levels to skip.</p>"},{"location":"concepts/#key-components","title":"Key Components","text":""},{"location":"concepts/#keys","title":"Keys","text":"<p>Keys are represented as sequences of directions (<code>L</code> = left = 0, <code>R</code> = right = 1). A 256-bit hash becomes a 256-element path through the tree.</p>"},{"location":"concepts/#indirect-references","title":"Indirect References","text":"<p>Each node stores an <code>Indirect</code> value containing:</p> <ul> <li>jump: The path prefix to skip (path compression)</li> <li>value: Either a hash (for internal nodes) or the actual value hash (for leaves)</li> </ul>"},{"location":"concepts/#hashing","title":"Hashing","text":"<p>The library uses Blake2b-256 for hashing. Internal node hashes are computed by hashing the concatenation of the encoded left and right children.</p>"},{"location":"concepts/#proofs","title":"Proofs","text":""},{"location":"concepts/#inclusion-proofs","title":"Inclusion Proofs","text":"<p>An inclusion proof demonstrates that a key-value pair exists in the tree. It contains:</p> <ul> <li>The key and value being proven</li> <li>The expected root hash</li> <li>Sibling hashes along the path from leaf to root</li> <li>Jump paths at each level</li> </ul> <p>To verify, recompute the root hash from the value and siblings, then compare with the expected root.</p> <p>See Inclusion Proof Format for the complete CBOR wire format specification.</p>"},{"location":"concepts/#completeness-proofs","title":"Completeness Proofs","text":"<p>A completeness proof demonstrates that a set of values comprises the entire tree contents. It consists of:</p> <ol> <li>All leaf values</li> <li>A sequence of merge operations to reconstruct the tree</li> </ol>"},{"location":"concepts/#storage-model","title":"Storage Model","text":"<p>The CSMT uses two storage columns:</p> Column Key Value KV Original key Original value CSMT Path prefix Indirect (jump + hash) <p>This dual storage allows:</p> <ul> <li>Efficient tree operations via the CSMT column</li> <li>Retrieval of original values via the KV column</li> <li>Proof generation using both columns</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>There is currently no releasing in place, but you can install via the provided artifacts from the CI.</p>"},{"location":"installation/#docker-images","title":"Docker images","text":"<pre><code>gh run download -n csmt-image\ni=$(docker load &lt; csmt-image | sed -e 's/Loaded image: //')\ndocker run $i\n</code></pre>"},{"location":"installation/#arx-self-executable-bundles","title":"Arx self-executable bundles","text":"<pre><code>gh run download -n csmt.arx\n./csmt.arx\n</code></pre>"},{"location":"installation/#rpm-packages","title":"RPM packages","text":"<pre><code>gh run download -n csmt-rpm\nsudo rpm -i csmt.rpm\n</code></pre>"},{"location":"installation/#deb-packages","title":"DEB packages","text":"<pre><code>gh run download -n csmt-deb\nsudo dpkg -i csmt.deb\n</code></pre>"},{"location":"installation/#building-from-source","title":"Building from source","text":"<p>You can build with nix</p> <pre><code>nix shell nixpkgs#cachix -c cachix use paolino\nnix shell github:paolino/csmt --refresh\n</code></pre> <p>Or via cabal provided you have a working Haskell environment and rocksdb development files installed.</p> <pre><code>cabal install\n</code></pre>"},{"location":"library/","title":"Library API","text":"<p>This page covers using the CSMT library in Haskell applications.</p>"},{"location":"library/#overview","title":"Overview","text":"<p>The library provides:</p> <ul> <li><code>CSMT</code> - Main module re-exporting the public API</li> <li><code>CSMT.Hashes</code> - Blake2b-256 based operations</li> <li><code>CSMT.Backend.RocksDB</code> - Persistent storage backend</li> <li><code>CSMT.Backend.Pure</code> - In-memory backend for testing</li> </ul>"},{"location":"library/#basic-setup","title":"Basic Setup","text":""},{"location":"library/#with-rocksdb-production","title":"With RocksDB (Production)","text":"<pre><code>import CSMT\nimport CSMT.Hashes\nimport CSMT.Backend.RocksDB\nimport CSMT.Backend.Standalone\n\n-- Open database and run operations\nmain :: IO ()\nmain = withRocksDB \"path/to/db\" 256 256 $ \\(RunRocksDB runDB) -&gt; do\n    db &lt;- runDB $ standaloneRocksDBDatabase codecs\n    -- Use db for transactions\n</code></pre>"},{"location":"library/#with-pure-backend-testing","title":"With Pure Backend (Testing)","text":"<pre><code>import CSMT\nimport CSMT.Backend.Pure\nimport CSMT.Backend.Standalone\n\n-- Run in-memory operations\nexample :: (result, InMemoryDB)\nexample = runPure emptyInMemoryDB $ do\n    runPureTransaction codecs $ do\n        -- Your operations here\n</code></pre>"},{"location":"library/#core-operations","title":"Core Operations","text":""},{"location":"library/#inserting-values","title":"Inserting Values","text":"<pre><code>import CSMT.Hashes (insert, fromKVHashes)\n\n-- Insert a key-value pair\ninsertExample :: Transaction m cf d ops ()\ninsertExample =\n    insert fromKVHashes kvCol csmtCol \"mykey\" \"myvalue\"\n</code></pre> <p>The <code>insert</code> function:</p> <ol> <li>Stores the key-value pair in the KV column</li> <li>Computes the value hash</li> <li>Updates the CSMT structure</li> <li>Recomputes affected node hashes</li> </ol>"},{"location":"library/#deleting-values","title":"Deleting Values","text":"<pre><code>import CSMT.Hashes (delete, fromKVHashes)\n\n-- Delete a key\ndeleteExample :: Transaction m cf d ops ()\ndeleteExample =\n    delete fromKVHashes kvCol csmtCol \"mykey\"\n</code></pre> <p>Deletion:</p> <ol> <li>Removes the key from the KV column</li> <li>Updates the tree structure (may compact nodes)</li> <li>Recomputes affected hashes</li> </ol>"},{"location":"library/#querying-the-root","title":"Querying the Root","text":"<pre><code>import CSMT.Hashes (root)\n\n-- Get current root hash\ngetRootExample :: Transaction m cf d ops (Maybe ByteString)\ngetRootExample = root csmtCol\n</code></pre> <p>Returns <code>Nothing</code> if the tree is empty.</p>"},{"location":"library/#merkle-proofs","title":"Merkle Proofs","text":""},{"location":"library/#generating-inclusion-proofs","title":"Generating Inclusion Proofs","text":"<pre><code>import CSMT.Hashes (generateInclusionProof, fromKVHashes)\n\n-- Generate proof for a key\nproofExample :: Transaction m cf d ops (Maybe (ByteString, ByteString))\nproofExample =\n    generateInclusionProof fromKVHashes kvCol csmtCol \"mykey\"\n</code></pre> <p>Returns <code>Maybe (value, proofBytes)</code>:</p> <ul> <li>Looks up the value from the KV column</li> <li>Returns both the value and serialized proof</li> <li>Returns <code>Nothing</code> if the key doesn't exist</li> </ul> <p>This ensures the proof is always consistent with the current tree state.</p>"},{"location":"library/#verifying-inclusion-proofs","title":"Verifying Inclusion Proofs","text":"<pre><code>import CSMT.Hashes (verifyInclusionProof)\n\n-- Verify a proof (pure function, no database access needed)\nverifyExample :: ByteString -&gt; Bool\nverifyExample proofBytes = verifyInclusionProof proofBytes\n</code></pre> <p>Returns <code>True</code> if the proof is internally consistent. The proof is self-contained with the key, value hash, and root hash embedded.</p> <p>To verify against a trusted root, parse the proof and compare <code>proofRootHash</code> with your known root.</p>"},{"location":"library/#custom-keyvalue-types","title":"Custom Key/Value Types","text":"<p>The library supports custom types via <code>FromKV</code>:</p> <pre><code>import CSMT.Interface (FromKV(..))\n\n-- Define conversion for your types\nmyFromKV :: FromKV MyKey MyValue Hash\nmyFromKV = FromKV\n    { fromK = myKeyToPath    -- Convert key to tree path\n    , fromV = myValueToHash  -- Convert value to hash\n    }\n</code></pre>"},{"location":"library/#codecs","title":"Codecs","text":"<p>For storage, define codecs using Prisms:</p> <pre><code>import CSMT.Backend.Standalone (StandaloneCodecs(..))\nimport Control.Lens (prism')\n\nmyCodecs :: StandaloneCodecs MyKey MyValue Hash\nmyCodecs = StandaloneCodecs\n    { keyCodec = prism' encodeKey decodeKey\n    , valueCodec = prism' encodeValue decodeValue\n    , nodeCodec = prism' encodeHash decodeHash\n    }\n</code></pre>"},{"location":"library/#column-selectors","title":"Column Selectors","text":"<p>Operations use type-safe column selectors from <code>CSMT.Backend.Standalone</code>:</p> <pre><code>import CSMT.Backend.Standalone (Standalone(..))\n\n-- Use directly as selectors\ninsert fromKVHashes StandaloneKVCol StandaloneCSMTCol key value\ndelete fromKVHashes StandaloneKVCol StandaloneCSMTCol key\ngenerateInclusionProof fromKVHashes StandaloneKVCol StandaloneCSMTCol key\n</code></pre> <p>The GADT constructors serve as selectors:</p> <ul> <li><code>StandaloneKVCol</code> - Selects the key-value column</li> <li><code>StandaloneCSMTCol</code> - Selects the CSMT tree column</li> </ul>"},{"location":"library/#error-handling","title":"Error Handling","text":"<p>Most operations return <code>Maybe</code> or are in a <code>Transaction</code> monad:</p> <ul> <li><code>Nothing</code> typically means \"key not found\"</li> <li>Invalid proofs return <code>False</code> from verification</li> <li>Database errors surface as exceptions</li> </ul>"},{"location":"library/#performance-tips","title":"Performance Tips","text":"<ol> <li>Batch operations: Group multiple inserts/deletes in a single transaction</li> <li>Column family tuning: Adjust <code>maxFiles</code> parameters for your workload</li> <li>Parallel insertion: Future versions will support parallel batch inserts</li> </ol>"},{"location":"manual/","title":"Manual","text":""},{"location":"manual/#cli-usage","title":"CLI Usage","text":"<p>The CSMT library comes with a command-line interface (CLI) tool that allows users to interact with the Compact Sparse Merkle Tree. The CLI provides various commands to perform operations such as adding and removing elements, generating proofs, and verifying membership within the tree.</p> <p>CLI works in interactive mode by default. You can also pass commands directly as stdin as we are doing in this manual.</p>"},{"location":"manual/#list-of-commands","title":"List of commands","text":"Command Description Arguments Return value <code>i</code> Insert a key-value pair key,  value <code>d</code> Delete a key key <code>q</code> Query inclusion proof for a key key base64 encoding of the proof <code>r</code> Get the current root of the CSMT base64 encoding of the root <code>v</code> Verify inclusion proof for a value value, proof<sup>1</sup> Valid or Invalid <code>w</code> Query value for a key key value <code>c</code> Comment (no operation)"},{"location":"manual/#basic-operations","title":"Basic operations","text":""},{"location":"manual/#setup","title":"Setup","text":"<p>Setup the environment variable <code>CSMT_DB_PATH</code> to point to a directory where the CSMT will store its data. For example:</p> Input <pre><code>export CSMT_DB_PATH=tmp/demo\nrm -rf $CSMT_DB_PATH\n</code></pre>"},{"location":"manual/#insertion","title":"Insertion","text":"InputOutput <pre><code>csmt &lt;&lt;$\ni key1 value1\nq key1\n$\n</code></pre> <pre><code>AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n</code></pre> <p>The <code>output</code> is the inclusion proof for <code>key1</code>. It will not change depending on the value associated with the key.</p> <p>Now the database contains the value for <code>key1</code>, and you can query its inclusion proof at any time.</p>"},{"location":"manual/#verification","title":"Verification","text":"InputOutput <pre><code>csmt &lt;&lt;$\nv value1 AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n$\n</code></pre> <pre><code>Valid\n</code></pre> <p>Now, if you try to verify the same proof with a different value</p> InputOutput <pre><code>csmt &lt;&lt;$\nv value2 AQDjun1C8tTl1kdY1oon8sAQWL86/UMiJyZFswQ9Sf49XQAA\n$\n</code></pre> <pre><code>Invalid\n</code></pre>"},{"location":"manual/#querying","title":"Querying","text":"<p>Currently you cannot inspect the keys, but you can ask for the values:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'w key1'\n</code></pre> <pre><code>value1\n</code></pre>"},{"location":"manual/#deletion","title":"Deletion","text":"<p>You can delete keys as well:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'd key1'\n</code></pre> <pre><code>DeletedKey\n</code></pre> <p>Now if you try to query for the inclusion proof of <code>key1</code> again:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'q key1'\n</code></pre> <pre><code>NoProofFound\n</code></pre> <p>Or if you try to get the value for <code>key1</code>:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'w key1'\n</code></pre> <pre><code>KeyNotFound\n</code></pre>"},{"location":"manual/#getting-the-root","title":"Getting the root","text":"<p>You can get the current root of the CSMT tree with the <code>r</code> command:</p> InputOutput <pre><code>csmt &lt;&lt;&lt; 'r'\n</code></pre> <pre><code>TreeEmpty\n</code></pre> <p>If you insert some keys first:</p> InputOutput <pre><code>csmt &lt;&lt;$\ni key1 value1\nr\ni key2 value2\nr\nd key2\nr\nd key1\nr\n$\n</code></pre> <pre><code>AddedKey\nNrJMih3czFriydMUwvFKFK6VYKZYVjKpKGe1WC4e+VU=\nAddedKey\njyW/0W96OAsUNpbd+SgA0B/ZjM8zGBOd3xR5Y1iOJOs=\nDeletedKey\nNrJMih3czFriydMUwvFKFK6VYKZYVjKpKGe1WC4e+VU=\nTreeEmpty\n</code></pre> <ol> <li> <p>In case the tree contains only one key, the proof argument has to be an empty string.\u00a0\u21a9</p> </li> </ol>"},{"location":"architecture/example/","title":"Worked Example","text":"<p>This example demonstrates how the CSMT stores data and computes hashes, applying the concepts from Storage.</p>"},{"location":"architecture/example/#simplified-hashing","title":"Simplified Hashing","text":"<p>For clarity, we use integers instead of Blake2b-256 hashes:</p> <ul> <li>Values: Plain integers (e.g., 13, 5, 19, 23)</li> <li>Hash combination: Addition instead of cryptographic hashing</li> <li>Key encoding: Binary representation (L=0, R=1)</li> </ul>"},{"location":"architecture/example/#input-data","title":"Input Data","text":"<p>We insert four key-value pairs:</p> Key Value LLRR 13 LRRL 5 LRRR 19 RLRL 23"},{"location":"architecture/example/#csmt-column-storage","title":"CSMT Column Storage","text":"<p>The tree is stored with path compression. Each entry has:</p> <ul> <li>Path prefix: The key path to reach this node</li> <li>Jump: Additional path to skip (path compression)</li> <li>Value/Hash: Leaf value or computed internal hash</li> </ul> Node Path Prefix Jump Hash Computation A [] - 66 0 + 41 + 2 + 23 (left child + right child with jumps) B [L] - 41 3 + 13 + 1 + 24 E [L,R] [R] 24 0 + 5 + 0 + 19 L1 [R] [L,R,L] 23 leaf value L2 [L,L] [R,R] 13 leaf value L3 [L,R,R,L] - 5 leaf value L4 [L,R,R,R] - 19 leaf value"},{"location":"architecture/example/#tree-visualization","title":"Tree Visualization","text":"<pre><code>graph TD\n    A[\"A: hash=66\"] --&gt; |L| B[\"B: hash=41\"]\n    A --&gt; |R| L1[\"L1: jump=LRL, val=23\"]\n    B --&gt; |L| L2[\"L2: jump=RR, val=13\"]\n    B --&gt; |R| E[\"E: jump=R, hash=24\"]\n    E --&gt; |L| L3[\"L3: val=5\"]\n    E --&gt; |R| L4[\"L4: val=19\"]</code></pre>"},{"location":"architecture/example/#understanding-the-structure","title":"Understanding the Structure","text":"<p>Leaf nodes (L1, L2, L3, L4): Store the actual values. L1 and L2 have jumps because they're the only nodes in their subtrees (path compression).</p> <p>Internal node with jump (E): At path <code>[L,R]</code> with jump <code>[R]</code>. Children are L3 and L4. Hash computation: <pre><code>E = jump(L3) + hash(L3) + jump(L4) + hash(L4)\n  = 0 + 5 + 0 + 19\n  = 24\n</code></pre></p> <p>Internal node (B): At path <code>[L]</code>, children are L2 and E. Hash computation: <pre><code>B = jump(L2) + hash(L2) + jump(E) + hash(E)\n  = RR + 13 + R + 24\n  = 3 + 13 + 1 + 24\n  = 41\n</code></pre></p> <p>Root node (A): At path <code>[]</code>, children are B and L1. Hash computation: <pre><code>A = jump(B) + hash(B) + jump(L1) + hash(L1)\n  = 0 + 41 + LRL + 23\n  = 0 + 41 + 2 + 23\n  = 66\n</code></pre></p> <p>Note: Jump values are converted to integers (L=0, R=1, then binary\u2192decimal). For example, <code>LRL</code> = 010 in binary = 2 in decimal.</p>"},{"location":"architecture/example/#path-compression-in-action","title":"Path Compression in Action","text":"<p>Notice how L1 at path <code>[R]</code> has jump <code>[L,R,L]</code>. This means the full key <code>RLRL</code> is stored as:</p> <ul> <li>Path prefix: <code>[R]</code> (stored as the database key)</li> <li>Jump: <code>[L,R,L]</code> (stored in the Indirect value)</li> </ul> <p>Without compression, we'd need intermediate nodes at <code>[R,L]</code> and <code>[R,L,R]</code>. The jump eliminates these unnecessary nodes.</p>"},{"location":"architecture/inclusion-proof/","title":"Inclusion Proof Format","text":"<p>Inclusion proofs allow verifying that a key-value pair exists in a CSMT without access to the full tree. Proofs are serialized using CBOR for compact, portable representation.</p>"},{"location":"architecture/inclusion-proof/#overview","title":"Overview","text":"<p>An inclusion proof is self-contained: it includes all information needed to verify membership, including the key, value hash, and expected root hash. Verification is pure computation with no database access required.</p> <pre><code>graph TD\n    subgraph \"Inclusion Proof\"\n        K[proof_key]\n        V[proof_value]\n        R[proof_root_hash]\n        S[proof_steps]\n        J[proof_root_jump]\n    end\n\n    subgraph \"Verification\"\n        V --&gt; |start| C[Compute]\n        S --&gt; |siblings| C\n        K --&gt; |directions| C\n        J --&gt; |apply| C\n        C --&gt; |compare| R\n    end</code></pre>"},{"location":"architecture/inclusion-proof/#cddl-specification","title":"CDDL Specification","text":"<p>The proof format is formally specified in CDDL (Concise Data Definition Language):</p> <pre><code>; CDDL specification for CSMT Inclusion Proof\n; CBOR encoding used by CSMT.Hashes.CBOR module\n\n; Direction in the merkle tree path (L=0, R=1)\ndirection = 0 / 1\n\n; Key is a path through the tree as a list of directions\nkey = [* direction]\n\n; Blake2b-256 hash (32 bytes)\nhash = bstr .size 32\n\n; Indirect node: jump path and hash value\nindirect = [\n    jump: key,\n    value: hash\n]\n\n; Proof step: bits consumed and sibling node\nproof_step = [\n    step_consumed: int,\n    step_sibling: indirect\n]\n\n; Complete inclusion proof\ninclusion_proof = [\n    proof_key: key,         ; The key being proven\n    proof_value: hash,      ; Hash of the value at the key\n    proof_root_hash: hash,  ; Root hash this proves against\n    proof_steps: [* proof_step],\n    proof_root_jump: key    ; Jump path at the root\n]\n</code></pre>"},{"location":"architecture/inclusion-proof/#data-types","title":"Data Types","text":""},{"location":"architecture/inclusion-proof/#direction","title":"Direction","text":"<p>A single bit indicating left (<code>0</code>) or right (<code>1</code>) in the tree traversal.</p> <pre><code>data Direction = L | R\n</code></pre>"},{"location":"architecture/inclusion-proof/#key","title":"Key","text":"<p>A path through the tree represented as a list of directions. For Blake2b-256 hashed keys, this is 256 directions (one per bit of the hash).</p> <pre><code>type Key = [Direction]\n</code></pre>"},{"location":"architecture/inclusion-proof/#indirect","title":"Indirect","text":"<p>A tree node reference containing:</p> Field Type Description <code>jump</code> <code>Key</code> Path prefix to skip (sparse tree optimization) <code>value</code> <code>Hash</code> Hash value of the node <pre><code>data Indirect a = Indirect { jump :: Key, value :: a }\n</code></pre>"},{"location":"architecture/inclusion-proof/#proofstep","title":"ProofStep","text":"<p>Each step in the proof records what's needed to compute one level of the Merkle tree:</p> Field Type Description <code>stepConsumed</code> <code>Int</code> Key bits consumed: 1 (direction) + length of jump <code>stepSibling</code> <code>Indirect</code> Sibling node for hash combination <p>The direction and jump path are derived from the key during verification, not stored in the step. This reduces proof size.</p> <pre><code>data ProofStep a = ProofStep\n    { stepConsumed :: Int\n    , stepSibling :: Indirect a\n    }\n</code></pre>"},{"location":"architecture/inclusion-proof/#inclusionproof","title":"InclusionProof","text":"<p>The complete self-contained proof:</p> Field Type Description <code>proofKey</code> <code>Key</code> The key being proven <code>proofValue</code> <code>Hash</code> Hash of the value at the key <code>proofRootHash</code> <code>Hash</code> Expected root hash <code>proofSteps</code> <code>[ProofStep]</code> Steps from leaf to root <code>proofRootJump</code> <code>Key</code> Jump path at the root node <pre><code>data InclusionProof a = InclusionProof\n    { proofKey :: Key\n    , proofValue :: a\n    , proofRootHash :: a\n    , proofSteps :: [ProofStep a]\n    , proofRootJump :: Key\n    }\n</code></pre>"},{"location":"architecture/inclusion-proof/#verification-algorithm","title":"Verification Algorithm","text":"<p>Verification recomputes the root hash and compares it to <code>proofRootHash</code>:</p> <pre><code>verifyInclusionProof(proof):\n    computed = computeRootHash(proof)\n    return computed == proof.proofRootHash\n</code></pre> <p>The <code>computeRootHash</code> algorithm:</p> <ol> <li>Start with <code>proofValue</code> as the current accumulator</li> <li>Compute <code>keyAfterRoot = drop(length(proofRootJump), proofKey)</code></li> <li>Reverse <code>keyAfterRoot</code> (proof steps are leaf-to-root, key is root-to-leaf)</li> <li>For each step in <code>proofSteps</code>:<ul> <li>Take <code>stepConsumed</code> bits from the reversed key</li> <li>First bit is the direction, remaining bits are the jump</li> <li>Combine current accumulator with <code>stepSibling</code> using the direction:<ul> <li>If direction is <code>L</code>: <code>hash(Indirect(jump, acc) || stepSibling)</code></li> <li>If direction is <code>R</code>: <code>hash(stepSibling || Indirect(jump, acc))</code></li> </ul> </li> <li>Result becomes the new accumulator</li> </ul> </li> <li>Apply <code>proofRootJump</code>: <code>rootHash(Indirect(proofRootJump, accumulator))</code></li> </ol>"},{"location":"architecture/inclusion-proof/#example","title":"Example","text":"<p>Consider a tree with key <code>[L, R, L]</code> and value hash <code>0xabc...</code>:</p> <pre><code>Tree structure:\n    Root (jump=[])\n     |\n     L\n     |\n   Node (jump=[])\n    / \\\n   R   L\n   |   |\n  Leaf Sibling\n</code></pre> <p>The proof would contain:</p> <pre><code>InclusionProof {\n    proofKey = [L, R, L],\n    proofValue = 0xabc...,\n    proofRootHash = 0xdef...,\n    proofSteps = [\n        ProofStep { stepConsumed = 1, stepSibling = Indirect [] 0x111... },\n        ProofStep { stepConsumed = 1, stepSibling = Indirect [] 0x222... }\n    ],\n    proofRootJump = []\n}\n</code></pre> <p>Verification: 1. Start with <code>acc = 0xabc...</code> 2. Step 1: direction=<code>L</code>, combine <code>acc</code> with sibling <code>0x222...</code> \u2192 <code>acc' = hash(...)</code> 3. Step 2: direction=<code>R</code>, combine <code>acc'</code> with sibling <code>0x111...</code> \u2192 <code>acc'' = hash(...)</code> 4. Apply root jump: <code>rootHash(Indirect [] acc'')</code> 5. Compare with <code>proofRootHash</code></p>"},{"location":"architecture/inclusion-proof/#security-considerations","title":"Security Considerations","text":"<p>The verifier must independently trust <code>proofRootHash</code>. Typical trust sources:</p> <ul> <li>Blockchain consensus (root hash stored on-chain)</li> <li>Trusted third party attestation</li> <li>Previous verified state</li> </ul> <p>The proof only demonstrates internal consistency\u2014it cannot prove the root hash itself is legitimate.</p>"},{"location":"architecture/storage/","title":"Storage Layer","text":"<p>The CSMT uses a dual-column storage model with RocksDB as the backend.</p>"},{"location":"architecture/storage/#column-families","title":"Column Families","text":"<pre><code>graph LR\n    subgraph \"KV Column\"\n        K1[user key] --&gt; V1[user value]\n        K2[user key] --&gt; V2[user value]\n    end\n\n    subgraph \"CSMT Column\"\n        P1[path prefix] --&gt; I1[Indirect]\n        P2[path prefix] --&gt; I2[Indirect]\n    end</code></pre> Column Key Type Value Type Purpose KV User key (<code>k</code>) User value (<code>v</code>) Store original key-value pairs CSMT Path prefix (<code>Key</code>) <code>Indirect a</code> Store Merkle tree nodes"},{"location":"architecture/storage/#csmt-node-storage","title":"CSMT Node Storage","text":"<p>Each node in the CSMT is stored as a key-value pair:</p> <ul> <li>Key: The path prefix (list of directions from root)</li> <li>Value: An <code>Indirect</code> containing:<ul> <li><code>jump</code>: Additional path to skip (path compression)</li> <li><code>value</code>: Hash of the node</li> </ul> </li> </ul> <pre><code>data Indirect a = Indirect\n    { jump :: Key      -- Path compression\n    , value :: a       -- Hash value\n    }\n</code></pre>"},{"location":"architecture/storage/#example","title":"Example","text":"<p>For a tree containing keys <code>[L,L,R,R]</code> and <code>[L,R,R,L]</code>:</p> <pre><code>CSMT Column:\n  []      -&gt; Indirect { jump = [L], value = hash1 }\n  [L,L]   -&gt; Indirect { jump = [R,R], value = leafHash1 }\n  [L,R]   -&gt; Indirect { jump = [R,L], value = leafHash2 }\n</code></pre> <p>The root node at <code>[]</code> has <code>jump = [L]</code> because both keys share the <code>L</code> prefix.</p>"},{"location":"architecture/storage/#path-compression","title":"Path Compression","text":"<p>The <code>jump</code> field enables path compression. Instead of storing every node along a path, we store only the nodes where the tree branches, with <code>jump</code> indicating how many levels to skip.</p> <pre><code>graph TD\n    subgraph \"Without Compression\"\n        R1[Root] --&gt; L1[L]\n        L1 --&gt; LL[LL]\n        LL --&gt; LLR[LLR]\n        LLR --&gt; LLRR[LLRR - leaf]\n    end\n\n    subgraph \"With Compression\"\n        R2[\"[] jump=[L]\"] --&gt; LL2[\"[L,L] jump=[R,R] - leaf\"]\n    end</code></pre>"},{"location":"architecture/storage/#preimage-storage-kv-column","title":"Preimage Storage (KV Column)","text":"<p>The KV column stores the original key-value pairs, enabling:</p> <ul> <li>Retrieval of original values given a key</li> <li>Proof generation (needs both key and value)</li> <li>Value lookup after proof verification</li> </ul> <pre><code>KV Column:\n  \"mykey\"   -&gt; \"myvalue\"\n  \"another\" -&gt; \"data\"\n</code></pre>"},{"location":"architecture/storage/#hash-composition","title":"Hash Composition","text":"<p>The Merkle tree hash is computed using Blake2b-256. The <code>Hashing</code> record defines how hashes are combined:</p> <pre><code>data Hashing a = Hashing\n    { rootHash :: Indirect a -&gt; a\n    , combineHash :: Indirect a -&gt; Indirect a -&gt; a\n    }\n</code></pre>"},{"location":"architecture/storage/#rootleaf-hash","title":"Root/Leaf Hash","text":"<p>For a single node (leaf or root), the hash is computed by serializing the entire <code>Indirect</code> structure:</p> <pre><code>rootHash(Indirect{jump, value}) = blake2b(serialize(jump) ++ serialize(value))\n</code></pre> <p>This means the jump path is included in the hash, ensuring path compression doesn't change the Merkle root.</p>"},{"location":"architecture/storage/#combining-child-hashes","title":"Combining Child Hashes","text":"<p>For internal nodes, the parent hash combines both children's <code>Indirect</code> values:</p> <pre><code>combineHash(left, right) = blake2b(serialize(left) ++ serialize(right))\n</code></pre> <p>Both the jump paths and hash values of children contribute to the parent hash.</p>"},{"location":"architecture/storage/#direction-based-ordering","title":"Direction-Based Ordering","text":"<p>The <code>addWithDirection</code> function determines child ordering based on the direction taken to reach the current node:</p> <pre><code>addWithDirection hashing L left right = combineHash left right\naddWithDirection hashing R left right = combineHash right left\n</code></pre> <ul> <li>Direction <code>L</code>: current node is on the left, sibling on right</li> <li>Direction <code>R</code>: current node is on the right, sibling on left</li> </ul>"},{"location":"architecture/storage/#serialization","title":"Serialization","text":"<p>Keys and Indirect values are serialized to ByteStrings for storage.</p>"},{"location":"architecture/storage/#keyjump-encoding","title":"Key/Jump Encoding","text":"<p>Keys (and jumps, which are key infixes) are bitstrings of arbitrary length. We use a Word16 big-endian to encode the length in bits, followed by the bits packed into bytes (left-aligned).</p> Key/Jump Encoding (empty) 0x00 0x00 L 0x00 0x01 0x00 R 0x00 0x01 0x80 LL 0x00 0x02 0x00 LR 0x00 0x02 0x40 RL 0x00 0x02 0x80 RR 0x00 0x02 0xc0 LLLLLLLL 0x00 0x08 0x00 RRRRRRRR 0x00 0x08 0xff LLLLLLLLL 0x00 0x09 0x00 0x00 RRRRRRRRR 0x00 0x09 0xff 0x80 <p>The bit length also determines byte length:</p> <pre><code>bytesLength len =\n    let (l, r) = len `divMod` 8\n    in if r == 0 then l else l + 1\n</code></pre>"},{"location":"architecture/storage/#bytestringhash-encoding","title":"ByteString/Hash Encoding","text":"<p>ByteStrings are stored as Word16 big-endian length followed by the bytes. Hashes are treated as variable-length bytestrings.</p> ByteString Encoding (empty) 0x00 0x00 \"a\" 0x00 0x01 0x61 \"abc\" 0x00 0x03 0x61 0x62 0x63 \"hello\" 0x00 0x05 0x68 0x65 0x6c 0x6c 0x6f"},{"location":"architecture/storage/#node-indirect-encoding","title":"Node (Indirect) Encoding","text":"<p>Nodes are encoded as jump encoding followed by hash encoding:</p> Node Encoding <code>{jump: \"\", value: \"abc\"}</code> 0x00 0x00 0x00 0x03 0x61 0x62 0x63 <code>{jump: \"LRL\", value: \"data\"}</code> 0x00 0x03 0x40 0x00 0x04 0x64 0x61 0x74 0x61"},{"location":"architecture/storage/#backend-interface","title":"Backend Interface","text":"<p>The storage layer is abstracted through the <code>Standalone</code> GADT:</p> <pre><code>data Standalone k v a x where\n    StandaloneKVCol   :: Standalone k v a (KV k v)\n    StandaloneCSMTCol :: Standalone k v a (KV Key (Indirect a))\n</code></pre> <p>This allows the same CSMT operations to work with different storage backends (RocksDB, in-memory, etc.) by providing appropriate codecs.</p>"},{"location":"architecture/system/","title":"System Overview","text":"<p>The CSMT system provides multiple interfaces for interacting with the tree.</p>"},{"location":"architecture/system/#current-architecture","title":"Current Architecture","text":"<pre><code>graph TD\n    L[CSMT CLI] --&gt;|CSMT Operations| C[CSMT Library]\n    H[Haskell Application] --&gt;|CSMT Operations| C\n    C --&gt;|Read/Write Nodes &amp; Preimages| D[RocksDB Storage]</code></pre> <p>A CSMT instance consists of:</p> <ul> <li>RocksDB Storage: Persistent backend for tree nodes and preimages</li> <li>CSMT Library: Core Haskell implementation of the data structure</li> <li>CLI Tool: Interactive command-line interface for tree operations</li> </ul>"},{"location":"architecture/system/#planned-architecture","title":"Planned Architecture","text":"<pre><code>graph TD\n    A[Client] --&gt;|HTTP Requests| B[CSMT HTTP Service]\n    B --&gt;|CSMT Operations| C[CSMT Library]\n    L[CSMT CLI] --&gt;|CSMT Operations| C\n    H[Haskell Application] --&gt;|CSMT Operations| C\n    C --&gt;|Read/Write Nodes &amp; Preimages| D[RocksDB Storage]</code></pre> <p>A future HTTP service will expose the CSMT functionalities via a RESTful API.</p>"}]}